pipeline {
    agent any
    
    environment {
        APP_NAME = 'cptsd-blog-public'
        DEPLOY_PATH = '/opt/cptsd-blog-public'
        DOCKER_COMPOSE_FILE = 'docker-compose.yml'
        DOCKER_COMPOSE_PROD_FILE = 'docker-compose.prod.yml'
        DOMAIN = 'blog.cptsd.in'
        
        // Environment variables from Jenkins job configuration (if set)
        // These will be used if .env files are not found
        // To set these in Jenkins:
        //   Option 1: Manage Jenkins → Configure System → Global properties → Environment variables
        //   Option 2: Job → Configure → This project is parameterized → Add String Parameters
        // These variables inherit from Jenkins global properties or job parameters
        // If not set in Jenkins, they will default to empty string and be loaded from .env files
    }
    
    stages {
        stage('Checkout') {
            steps {
                script {
                    // Clean workspace
                    sh 'rm -rf * .* || true'
                }
                checkout scm
            }
        }
        
        stage('Build') {
            steps {
                dir('cptsd-blog-public') {
                    script {
                        echo "Building ${APP_NAME} Docker image..."
                        sh """
                            # Use environment variables from Jenkins Global Properties
                            # These are set via: Manage Jenkins → Configure System → Global properties → Environment variables
                            # Variables are automatically available in Jenkins pipeline, just export them for docker-compose
                            
                            # Export environment variables for docker-compose build
                            # Jenkins Global Properties are already available as environment variables
                            export MONGODB_URI=\${MONGODB_URI:-}
                            
                            # Build image once (will be reused in deploy stage)
                            docker-compose -f ${DOCKER_COMPOSE_FILE} build app
                        """
                    }
                }
            }
        }
        
        stage('Test') {
            steps {
                dir('cptsd-blog-public') {
                    script {
                        echo 'Running tests...'
                        sh '''
                            docker-compose -f ${DOCKER_COMPOSE_FILE} run --rm app npm test || echo "Tests failed but continuing..."
                        '''
                    }
                }
            }
        }
        
        stage('Deploy') {
            steps {
                script {
                    echo "Deploying ${APP_NAME} to ${DOMAIN}..."
                    sh """
                        # Copy files to deployment directory
                        mkdir -p ${DEPLOY_PATH}
                        cp -r cptsd-blog-public/* ${DEPLOY_PATH}/
                        
                        # Navigate to deployment directory
                        cd ${DEPLOY_PATH}
                        
                        # Pull latest code if using git
                        if [ -d .git ]; then
                            git pull origin main || git pull origin master || true
                        fi
                        
                        # Use environment variables from Jenkins Global Properties
                        # These are set via: Manage Jenkins → Configure System → Global properties → Environment variables
                        # Variables are automatically available in Jenkins pipeline, just export them for docker-compose
                        
                        # Export environment variables for docker-compose
                        # Jenkins Global Properties are already available as environment variables
                        export MONGODB_URI=\${MONGODB_URI:-}
                        
                        # Stop and remove existing containers properly (including orphans)
                        echo "Stopping existing containers..."
                        docker-compose -f ${DOCKER_COMPOSE_FILE} -f ${DOCKER_COMPOSE_PROD_FILE} down --remove-orphans || true
                        
                        # Force remove any containers with conflicting names
                        echo "Removing any orphaned containers..."
                        docker rm -f cptsd-blog-public-app-1 2>/dev/null || true
                        
                        # The image was already built in the Build stage, so we don't rebuild here
                        # Docker will use the existing image from the build stage
                        echo "Using pre-built image from Build stage (no rebuild needed)..."
                        
                        # Start services (Docker will use the existing image)
                        docker-compose -f ${DOCKER_COMPOSE_FILE} -f ${DOCKER_COMPOSE_PROD_FILE} up -d
                        
                        # Wait for services to be healthy
                        sleep 30
                        
                        # Check service status
                        docker-compose -f ${DOCKER_COMPOSE_FILE} -f ${DOCKER_COMPOSE_PROD_FILE} ps
                    """
                }
            }
        }
        
        stage('Health Check') {
            steps {
                script {
                    echo "Performing health check for ${DOMAIN}..."
                    sh """
                        sleep 10
                        curl -f http://localhost:3001 || echo "Health check failed"
                    """
                }
            }
        }
    }
    
    post {
        success {
            echo "${APP_NAME} deployment to ${DOMAIN} successful!"
        }
        failure {
            echo "${APP_NAME} deployment to ${DOMAIN} failed!"
            sh 'docker-compose -f ${DEPLOY_PATH}/${DOCKER_COMPOSE_FILE} -f ${DEPLOY_PATH}/${DOCKER_COMPOSE_PROD_FILE} logs --tail=50'
        }
        always {
            cleanWs()
        }
    }
}

